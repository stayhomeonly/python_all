# coding:utf-8
"""
#@Time：2022/11/17-21:09
#@file：python_basic_66(名称空间)
#@Project:python_new_study
#@Content:

"""
'''
栈区指的是变量名，堆区指的是内存地址
名称空间（namespace）也是变量名：内置名称空间、全局名称空间、局部名称空间
作用域：全局作用域、局部作用域
全局作用域：内置名称空间、全局名称空间
'''


# 内置名称空间：用来存放python解释器的空间
# python解释器启动，就会创建内置名称空间，python解释器关闭，内置名称空间就会被销毁
# 全局名称空间： Python文件（模块）内定义的变量名：包含函数名、类名、模块名
# 要排除掉函数内部定义的名字（包括函数的参数）
# 总结：只要不是函数内部定义的名字、也不是内置的名字、剩下的就是属于全局名称空间的名字
# 全局名称空间：会在python文件执行之前产生，Python文件运行完毕销毁

# 局部名称空间：函数内部定义的名字（包括函数的参数）
# 在函数调用时产生，在调用结束后销毁

# 名称空间的查找优先级
# 局部名称空间>全局名称空间>内置名称空间


# x = 10
# def fun1():
#     print(x)   # 这个就属于定义阶段
#
#
# def fun2():
#     x = 20
#     fun1()  #这个就属于调用阶段
#
#
# fun2()  # 10 在调用fun1的时候先执行fun1里面的定义x，局部里面没有，再到全局

# 名称空间的查找顺序是以定义阶段为基准的

# 作用域

# 全局作用域：内置名称空间，全局名称空间
# 1、全局存活
# 2、全局有效

# 局部作用域：局部名称空间
# 1、临时存活
# 2、局部有效


# x = 10

# def func():
#     global x
#     x = 20
#
#
# func()
# print(x)  # 如果想把全局x变为20，加上gloal,这是针对不可变类型

# nonlocal
# x = 10
#
#
# def fun1():
#     x = 20
#
#     def fun2():
#         nonlocal x  # 就是在本层上面找x，如果上面一层没有就在上一层，一直到最上层，但是不会到
#         #全局去找
#         x = 30
#
#     print('调用fun2之前的x:', x)
#     fun2()
#     print('调用fun2之后的x:', x)
#
#
# fun1()
# print('全局的x', x)
# 如果只想把x=30上面的x=20变成30 ，用nonlocal


# 变量名：指向的是变量值的内存地址
# 函数名：指向的是函数的内存地址

def func():
    print('我是func')


x = func  # 不加括号表示传递的是函数的内存地址
print(x)
x = func()
print(x)  # None 打印的是函数名的值


